[{"C:\\Users\\Youn\\draft-app\\src\\index.js":"1","C:\\Users\\Youn\\draft-app\\src\\reportWebVitals.js":"2","C:\\Users\\Youn\\draft-app\\src\\App.js":"3","C:\\Users\\Youn\\draft-app\\src\\plugins\\index.js":"4","C:\\Users\\Youn\\draft-app\\src\\telemetry.js":"5","C:\\Users\\Youn\\draft-app\\src\\my-canvas\\index.js":"6","C:\\Users\\Youn\\draft-app\\src\\my-canvas\\drawImage.js":"7"},{"size":500,"mtime":499162500000,"results":"8","hashOfConfig":"9"},{"size":362,"mtime":499162500000,"results":"10","hashOfConfig":"9"},{"size":6819,"mtime":1620904265336,"results":"11","hashOfConfig":"9"},{"size":6269,"mtime":1620720838962,"results":"12","hashOfConfig":"9"},{"size":737,"mtime":1620796647745,"results":"13","hashOfConfig":"9"},{"size":16551,"mtime":1620711430493,"results":"14","hashOfConfig":"9"},{"size":1601,"mtime":1620709343966,"results":"15","hashOfConfig":"9"},{"filePath":"16","messages":"17","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},"1xx63hw",{"filePath":"19","messages":"20","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},{"filePath":"21","messages":"22","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"23","messages":"24","errorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"25","usedDeprecatedRules":"18"},{"filePath":"26","messages":"27","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},{"filePath":"28","messages":"29","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"30","usedDeprecatedRules":"18"},{"filePath":"31","messages":"32","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},"C:\\Users\\Youn\\draft-app\\src\\index.js",[],["33","34"],"C:\\Users\\Youn\\draft-app\\src\\reportWebVitals.js",[],"C:\\Users\\Youn\\draft-app\\src\\App.js",["35","36","37"],"C:\\Users\\Youn\\draft-app\\src\\plugins\\index.js",["38","39","40","41","42","43","44","45"],"import React from 'react';\r\nimport CanvasDraw from \"../my-canvas\";\r\n\r\nimport { List, Map } from 'immutable';\r\nimport {\r\n  EditorState,\r\n  Modifier,\r\n  SelectionState,\r\n  genKey,\r\n  ContentBlock\r\n} from 'draft-js';\r\n\r\nimport decorateComponentWithProps from 'decorate-component-with-props';\r\n\r\nclass MyCanvasDraw extends React.Component {\r\n  state = {\r\n    mode: 'pen'\r\n  };\r\n\r\n  onChangeSize = dir => {\r\n    let editorState = this.props.getEditorState();\r\n    let contentState = editorState.getCurrentContent();\r\n    let block = this.props.block;\r\n\r\n    let selectionState = new SelectionState({\r\n      anchorKey: block.getKey(),\r\n      anchorOffset: 0,\r\n      focusKey: block.getKey(),\r\n      focusOffset: 0\r\n    });\r\n\r\n    let blockData = Map();\r\n    let newHeight = block.getData().get('height');\r\n\r\n    if (dir == 'smaller') {\r\n      newHeight = newHeight == 200 ? 200 : newHeight - 100;\r\n    } else {\r\n      newHeight = newHeight == 600 ? 600 : newHeight + 100;\r\n    }\r\n\r\n    blockData = blockData.set('height', newHeight);\r\n\r\n    let newContentState = Modifier.mergeBlockData(contentState, selectionState, blockData);\r\n    let newEditorState = EditorState.push(editorState, newContentState, 'change-block-data');\r\n\r\n    this.props.setEditorState(newEditorState);\r\n  }\r\n\r\n  onToggleMode = () => {\r\n    console.log('onToggleMode');\r\n    \r\n    let editorState = this.props.getEditorState();\r\n    let contentState = editorState.getCurrentContent();\r\n    let block = this.props.block;\r\n\r\n    this.setState({\r\n      mode: block.getData().get('mode') == 'pen' ? 'eraser' : 'pen'\r\n    });\r\n\r\n    let selectionState = new SelectionState({\r\n      anchorKey: block.getKey(),\r\n      anchorOffset: 0,\r\n      focusKey: block.getKey(),\r\n      focusOffset: 0\r\n    });\r\n\r\n    let blockData = Map();\r\n    blockData = blockData.set('mode', block.getData().get('mode') == 'pen' ? 'eraser' : 'pen');\r\n\r\n    let newContentState = Modifier.mergeBlockData(contentState, selectionState, blockData);\r\n    let newEditorState = EditorState.push(editorState, newContentState, 'change-block-data');\r\n    this.props.setEditorState(newEditorState);\r\n  }\r\n\r\n  render() {\r\n    let block = this.props.block;\r\n    let height = block.getData().get('height');\r\n    let width = block.getData().get('size');\r\n    let mode = block.getData().get('mode');\r\n\r\n    let brush;\r\n\r\n    if (mode == 'pen') {\r\n      brush = {\r\n        radius: 1,\r\n        color: 'rgba(0, 0, 0, 1)'\r\n      };\r\n    } else {\r\n      brush = {\r\n        radius: 20,\r\n        color: 'rgba(255, 255, 255, 1)'\r\n      };\r\n    }\r\n\r\n    return (\r\n      <div style={{display: 'flex', flexDirection: 'row'}}>\r\n        <CanvasDraw\r\n          brushRadius={brush.radius}\r\n          brushColor={brush.color}\r\n          lazyRadius={0}\r\n          canvasHeight={height}\r\n          canvasWidth={width}\r\n          hideInterface={true}\r\n          gridColor='#7182AD'\r\n          ref={ref => this.canvasRef = ref }\r\n        />\r\n        <div style={{marginLeft: 5, display: 'flex', flexDirection: 'column'}}>\r\n          <button onClick={() => { this.onChangeSize('bigger'); }} style={{marginBottom: '5px'}}>\r\n            Bigger\r\n          </button>\r\n          <button onClick={() => { this.onChangeSize('smaller'); }} style={{marginBottom: '5px'}}>\r\n            Smaller\r\n          </button>\r\n          <button style={mode == 'eraser' ? {backgroundColor: 'orange', color: 'white'} : {}} onClick={() => {\r\n            this.canvasRef && this.canvasRef.undo();\r\n          }}>\r\n            Undo\r\n          </button>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nfunction handleSlashCommand(editorState) {\r\n  let selection = editorState.getSelection();\r\n  let contentState = editorState.getCurrentContent();\r\n  let currentBlock = contentState.getBlockForKey(selection.getStartKey());\r\n  let currentText = currentBlock.getText();\r\n\r\n  if (currentText == '/sketch') {\r\n    let selectionState = new SelectionState({\r\n      anchorKey: currentBlock.getKey(),\r\n      anchorOffset: 0,\r\n      focusKey: currentBlock.getKey(),\r\n      focusOffset: currentText.length\r\n    });\r\n\r\n    let newContentState = Modifier.setBlockType(contentState, selectionState, 'atomic');\r\n\r\n    let blockData = Map();\r\n    blockData = blockData.set('height', 400);\r\n    blockData = blockData.set('size', 800);\r\n    blockData = blockData.set('mode', 'pen');\r\n    newContentState = Modifier.mergeBlockData(newContentState, selectionState, blockData);\r\n\r\n    newContentState = newContentState.createEntity('CANVAS', 'IMMUTABLE', {content: ''});\r\n    let entityKey = newContentState.getLastCreatedEntityKey();\r\n\r\n    newContentState = Modifier.applyEntity(newContentState, selectionState, entityKey);\r\n  \r\n    let newEditorState = EditorState.push(editorState, newContentState, 'change-block-type');\r\n\r\n    const newBlock = new ContentBlock({\r\n      key: genKey(),\r\n      type: 'unstyled',\r\n      text: '',\r\n      characterList: List()\r\n    });\r\n\r\n    newContentState = newEditorState.getCurrentContent();\r\n    let newBlockMap = newContentState.getBlockMap().set(newBlock.key, newBlock);\r\n\r\n    newContentState = newContentState.merge({\r\n      blockMap: newBlockMap\r\n    });\r\n\r\n    newEditorState = EditorState.push(newEditorState, newContentState, 'add-block');\r\n\r\n    newEditorState = EditorState.forceSelection(newEditorState, new SelectionState({\r\n        anchorKey: newBlock.getKey(),\r\n        anchorOffset: 0,\r\n        focusKey: newBlock.getKey(),\r\n        focusOffset: 0\r\n      })\r\n    );\r\n\r\n    return newEditorState;\r\n  } else {\r\n    return editorState;\r\n  }\r\n}\r\n\r\nconst createSketchPlugin = config => {\r\n  const store = {};\r\n  return {\r\n    store,\r\n    initialize({ setEditorState, getEditorState }) {\r\n      store.setEditorState = setEditorState;\r\n      store.getEditorState = getEditorState;\r\n    },\r\n    handleBeforeInput(character, editorState) {\r\n      if (character.match(/[A-z-0-9_*~`]/)) {\r\n        return 'not-handled';\r\n      }\r\n\r\n      const newEditorState = handleSlashCommand(editorState);\r\n\r\n      if (editorState !== newEditorState) {\r\n        store.setEditorState(newEditorState);\r\n        return 'handled';\r\n      }\r\n\r\n      return 'not-handled';\r\n    },\r\n    MyCanvasDraw: decorateComponentWithProps(MyCanvasDraw, store)\r\n  };\r\n}\r\n\r\nexport default createSketchPlugin;","C:\\Users\\Youn\\draft-app\\src\\telemetry.js",[],"C:\\Users\\Youn\\draft-app\\src\\my-canvas\\index.js",["46"],"import React, { PureComponent } from \"react\";\r\nimport PropTypes from \"prop-types\";\r\nimport { LazyBrush } from \"lazy-brush\";\r\nimport { Catenary } from \"catenary-curve\";\r\n\r\nimport ResizeObserver from \"resize-observer-polyfill\";\r\n\r\nimport drawImage from \"./drawImage\";\r\n\r\nfunction midPointBtw(p1, p2) {\r\n  return {\r\n    x: p1.x + (p2.x - p1.x) / 2,\r\n    y: p1.y + (p2.y - p1.y) / 2\r\n  };\r\n}\r\n\r\nconst canvasStyle = {\r\n  display: \"block\",\r\n  position: \"absolute\"\r\n};\r\n\r\nconst canvasTypes = [\r\n  {\r\n    name: \"interface\",\r\n    zIndex: 15\r\n  },\r\n  {\r\n    name: \"drawing\",\r\n    zIndex: 11\r\n  },\r\n  {\r\n    name: \"temp\",\r\n    zIndex: 12\r\n  },\r\n  {\r\n    name: \"grid\",\r\n    zIndex: 10\r\n  }\r\n];\r\n\r\nconst dimensionsPropTypes = PropTypes.oneOfType([\r\n  PropTypes.number,\r\n  PropTypes.string\r\n]);\r\n\r\nexport default class extends PureComponent {\r\n  static propTypes = {\r\n    onChange: PropTypes.func,\r\n    loadTimeOffset: PropTypes.number,\r\n    lazyRadius: PropTypes.number,\r\n    brushRadius: PropTypes.number,\r\n    brushColor: PropTypes.string,\r\n    catenaryColor: PropTypes.string,\r\n    gridColor: PropTypes.string,\r\n    backgroundColor: PropTypes.string,\r\n    hideGrid: PropTypes.bool,\r\n    canvasWidth: dimensionsPropTypes,\r\n    canvasHeight: dimensionsPropTypes,\r\n    disabled: PropTypes.bool,\r\n    imgSrc: PropTypes.string,\r\n    saveData: PropTypes.string,\r\n    immediateLoading: PropTypes.bool,\r\n    hideInterface: PropTypes.bool\r\n  };\r\n\r\n  static defaultProps = {\r\n    onChange: null,\r\n    loadTimeOffset: 5,\r\n    lazyRadius: 12,\r\n    brushRadius: 10,\r\n    brushColor: \"#444\",\r\n    catenaryColor: \"#0a0302\",\r\n    gridColor: \"rgba(150,150,150,0.17)\",\r\n    backgroundColor: \"#FFF\",\r\n    hideGrid: false,\r\n    canvasWidth: 400,\r\n    canvasHeight: 400,\r\n    disabled: false,\r\n    imgSrc: \"\",\r\n    saveData: \"\",\r\n    immediateLoading: false,\r\n    hideInterface: false\r\n  };\r\n\r\n  constructor(props) {\r\n    super(props);\r\n\r\n    this.canvas = {};\r\n    this.ctx = {};\r\n\r\n    this.catenary = new Catenary();\r\n\r\n    this.points = [];\r\n    this.lines = [];\r\n\r\n    this.mouseHasMoved = true;\r\n    this.valuesChanged = true;\r\n    this.isDrawing = false;\r\n    this.isPressing = false;\r\n  }\r\n\r\n  componentDidMount() {\r\n    this.lazy = new LazyBrush({\r\n      radius: this.props.lazyRadius * window.devicePixelRatio,\r\n      enabled: true,\r\n      initialPoint: {\r\n        x: window.innerWidth / 2,\r\n        y: window.innerHeight / 2\r\n      }\r\n    });\r\n    this.chainLength = this.props.lazyRadius * window.devicePixelRatio;\r\n\r\n    this.canvasObserver = new ResizeObserver((entries, observer) =>\r\n      this.handleCanvasResize(entries, observer)\r\n    );\r\n    this.canvasObserver.observe(this.canvasContainer);\r\n\r\n    this.drawImage();\r\n    this.loop();\r\n\r\n    window.setTimeout(() => {\r\n      const initX = window.innerWidth / 2;\r\n      const initY = window.innerHeight / 2;\r\n      this.lazy.update(\r\n        { x: initX - this.chainLength / 4, y: initY },\r\n        { both: true }\r\n      );\r\n      this.lazy.update(\r\n        { x: initX + this.chainLength / 4, y: initY },\r\n        { both: false }\r\n      );\r\n      this.mouseHasMoved = true;\r\n      this.valuesChanged = true;\r\n      this.clear();\r\n\r\n      // Load saveData from prop if it exists\r\n      if (this.props.saveData) {\r\n        this.loadSaveData(this.props.saveData);\r\n      }\r\n    }, 100);\r\n  }\r\n\r\n  componentDidUpdate(prevProps) {\r\n    if (prevProps.lazyRadius !== this.props.lazyRadius) {\r\n      // Set new lazyRadius values\r\n      this.chainLength = this.props.lazyRadius * window.devicePixelRatio;\r\n      this.lazy.setRadius(this.props.lazyRadius * window.devicePixelRatio);\r\n    }\r\n\r\n    if (prevProps.saveData !== this.props.saveData) {\r\n      this.loadSaveData(this.props.saveData);\r\n    }\r\n\r\n    if (JSON.stringify(prevProps) !== JSON.stringify(this.props)) {\r\n      // Signal this.loop function that values changed\r\n      this.valuesChanged = true;\r\n    }\r\n  }\r\n\r\n  componentWillUnmount = () => {\r\n    this.canvasObserver.unobserve(this.canvasContainer);\r\n  };\r\n\r\n  drawImage = () => {\r\n    if (!this.props.imgSrc) return;\r\n\r\n    // Load the image\r\n    this.image = new Image();\r\n\r\n    // Prevent SecurityError \"Tainted canvases may not be exported.\" #70\r\n    this.image.crossOrigin = \"anonymous\";\r\n\r\n    // Draw the image once loaded\r\n    this.image.onload = () =>\r\n      drawImage({ ctx: this.ctx.grid, img: this.image });\r\n    this.image.src = this.props.imgSrc;\r\n  };\r\n\r\n  undo = () => {\r\n    const lines = this.lines.slice(0, -1);\r\n    this.clear();\r\n    this.simulateDrawingLines({ lines, immediate: true });\r\n    this.triggerOnChange();\r\n  };\r\n\r\n  getSaveData = () => {\r\n    // Construct and return the stringified saveData object\r\n    return JSON.stringify({\r\n      lines: this.lines,\r\n      width: this.props.canvasWidth,\r\n      height: this.props.canvasHeight\r\n    });\r\n  };\r\n\r\n  loadSaveData = (saveData, immediate = this.props.immediateLoading) => {\r\n    if (typeof saveData !== \"string\") {\r\n      throw new Error(\"saveData needs to be of type string!\");\r\n    }\r\n\r\n    const { lines, width, height } = JSON.parse(saveData);\r\n\r\n    if (!lines || typeof lines.push !== \"function\") {\r\n      throw new Error(\"saveData.lines needs to be an array!\");\r\n    }\r\n\r\n    this.clear();\r\n\r\n    if (\r\n      width === this.props.canvasWidth &&\r\n      height === this.props.canvasHeight\r\n    ) {\r\n      this.simulateDrawingLines({\r\n        lines,\r\n        immediate\r\n      });\r\n    } else {\r\n      // we need to rescale the lines based on saved & current dimensions\r\n      const scaleX = this.props.canvasWidth / width;\r\n      const scaleY = this.props.canvasHeight / height;\r\n      const scaleAvg = (scaleX + scaleY) / 2;\r\n\r\n      this.simulateDrawingLines({\r\n        lines: lines.map(line => ({\r\n          ...line,\r\n          points: line.points.map(p => ({\r\n            x: p.x * scaleX,\r\n            y: p.y * scaleY\r\n          })),\r\n          brushRadius: line.brushRadius * scaleAvg\r\n        })),\r\n        immediate\r\n      });\r\n    }\r\n  };\r\n\r\n  simulateDrawingLines = ({ lines, immediate }) => {\r\n    // Simulate live-drawing of the loaded lines\r\n    // TODO use a generator\r\n    let curTime = 0;\r\n    let timeoutGap = immediate ? 0 : this.props.loadTimeOffset;\r\n\r\n    lines.forEach(line => {\r\n      const { points, brushColor, brushRadius } = line;\r\n\r\n      // Draw all at once if immediate flag is set, instead of using setTimeout\r\n      if (immediate) {\r\n        // Draw the points\r\n        this.drawPoints({\r\n          points,\r\n          brushColor,\r\n          brushRadius\r\n        });\r\n\r\n        // Save line with the drawn points\r\n        this.points = points;\r\n        this.saveLine({ brushColor, brushRadius });\r\n        return;\r\n      }\r\n\r\n      // Use timeout to draw\r\n      for (let i = 1; i < points.length; i++) {\r\n        curTime += timeoutGap;\r\n        window.setTimeout(() => {\r\n          this.drawPoints({\r\n            points: points.slice(0, i + 1),\r\n            brushColor,\r\n            brushRadius\r\n          });\r\n        }, curTime);\r\n      }\r\n\r\n      curTime += timeoutGap;\r\n      window.setTimeout(() => {\r\n        // Save this line with its props instead of this.props\r\n        this.points = points;\r\n        this.saveLine({ brushColor, brushRadius });\r\n      }, curTime);\r\n    });\r\n  };\r\n\r\n  handleDrawStart = e => {\r\n    e.preventDefault();\r\n\r\n    // Start drawing\r\n    this.isPressing = true;\r\n\r\n    const { x, y } = this.getPointerPos(e);\r\n\r\n    if (e.touches && e.touches.length > 0) {\r\n      // on touch, set catenary position to touch pos\r\n      this.lazy.update({ x, y }, { both: true });\r\n    }\r\n\r\n    // Ensure the initial down position gets added to our line\r\n    this.handlePointerMove(x, y);\r\n  };\r\n\r\n  handleDrawMove = e => {\r\n    e.preventDefault();\r\n\r\n    const { x, y } = this.getPointerPos(e);\r\n    this.handlePointerMove(x, y);\r\n  };\r\n\r\n  handleDrawEnd = e => {\r\n    e.preventDefault();\r\n\r\n    // Draw to this end pos\r\n    this.handleDrawMove(e);\r\n\r\n    // Stop drawing & save the drawn line\r\n    this.isDrawing = false;\r\n    this.isPressing = false;\r\n    this.saveLine();\r\n  };\r\n\r\n  handleCanvasResize = (entries, observer) => {\r\n    const saveData = this.getSaveData();\r\n    for (const entry of entries) {\r\n      const { width, height } = entry.contentRect;\r\n      this.setCanvasSize(this.canvas.interface, width, height);\r\n      this.setCanvasSize(this.canvas.drawing, width, height);\r\n      this.setCanvasSize(this.canvas.temp, width, height);\r\n      this.setCanvasSize(this.canvas.grid, width, height);\r\n\r\n      this.drawGrid(this.ctx.grid);\r\n      this.drawImage();\r\n      this.loop({ once: true });\r\n    }\r\n    this.loadSaveData(saveData, true);\r\n  };\r\n\r\n  setCanvasSize = (canvas, width, height) => {\r\n    canvas.width = width;\r\n    canvas.height = height;\r\n    canvas.style.width = width;\r\n    canvas.style.height = height;\r\n  };\r\n\r\n  getPointerPos = e => {\r\n    const rect = this.canvas.interface.getBoundingClientRect();\r\n\r\n    // use cursor pos as default\r\n    let clientX = e.clientX;\r\n    let clientY = e.clientY;\r\n\r\n    // use first touch if available\r\n    if (e.changedTouches && e.changedTouches.length > 0) {\r\n      clientX = e.changedTouches[0].clientX;\r\n      clientY = e.changedTouches[0].clientY;\r\n    }\r\n\r\n    // return mouse/touch position inside canvas\r\n    return {\r\n      x: clientX - rect.left,\r\n      y: clientY - rect.top\r\n    };\r\n  };\r\n\r\n  handlePointerMove = (x, y) => {\r\n    if (this.props.disabled) return;\r\n\r\n    this.lazy.update({ x, y });\r\n    const isDisabled = !this.lazy.isEnabled();\r\n\r\n    if (\r\n      (this.isPressing && !this.isDrawing) ||\r\n      (isDisabled && this.isPressing)\r\n    ) {\r\n      // Start drawing and add point\r\n      this.isDrawing = true;\r\n      this.points.push(this.lazy.brush.toObject());\r\n    }\r\n\r\n    if (this.isDrawing) {\r\n      // Add new point\r\n      this.points.push(this.lazy.brush.toObject());\r\n\r\n      // Draw current points\r\n      this.drawPoints({\r\n        points: this.points,\r\n        brushColor: this.props.brushColor,\r\n        brushRadius: this.props.brushRadius\r\n      });\r\n    }\r\n\r\n    this.mouseHasMoved = true;\r\n  };\r\n\r\n  drawPoints = ({ points, brushColor, brushRadius }) => {\r\n    this.ctx.temp.lineJoin = \"round\";\r\n    this.ctx.temp.lineCap = \"round\";\r\n    this.ctx.temp.strokeStyle = brushColor;\r\n\r\n    this.ctx.temp.clearRect(\r\n      0,\r\n      0,\r\n      this.ctx.temp.canvas.width,\r\n      this.ctx.temp.canvas.height\r\n    );\r\n    this.ctx.temp.lineWidth = brushRadius * 2;\r\n\r\n    let p1 = points[0];\r\n    let p2 = points[1];\r\n\r\n    this.ctx.temp.moveTo(p2.x, p2.y);\r\n    this.ctx.temp.beginPath();\r\n\r\n    for (var i = 1, len = points.length; i < len; i++) {\r\n      // we pick the point between pi+1 & pi+2 as the\r\n      // end point and p1 as our control point\r\n      var midPoint = midPointBtw(p1, p2);\r\n      this.ctx.temp.quadraticCurveTo(p1.x, p1.y, midPoint.x, midPoint.y);\r\n      p1 = points[i];\r\n      p2 = points[i + 1];\r\n    }\r\n    // Draw last line as a straight line while\r\n    // we wait for the next point to be able to calculate\r\n    // the bezier control point\r\n    this.ctx.temp.lineTo(p1.x, p1.y);\r\n    this.ctx.temp.stroke();\r\n  };\r\n\r\n  saveLine = ({ brushColor, brushRadius } = {}) => {\r\n    if (this.points.length < 2) return;\r\n\r\n    // Save as new line\r\n    this.lines.push({\r\n      points: [...this.points],\r\n      brushColor: brushColor || this.props.brushColor,\r\n      brushRadius: brushRadius || this.props.brushRadius\r\n    });\r\n\r\n    // Reset points array\r\n    this.points.length = 0;\r\n\r\n    const width = this.canvas.temp.width;\r\n    const height = this.canvas.temp.height;\r\n\r\n    // Copy the line to the drawing canvas\r\n    this.ctx.drawing.drawImage(this.canvas.temp, 0, 0, width, height);\r\n\r\n    // Clear the temporary line-drawing canvas\r\n    this.ctx.temp.clearRect(0, 0, width, height);\r\n\r\n    this.triggerOnChange();\r\n  };\r\n\r\n  triggerOnChange = () => {\r\n    this.props.onChange && this.props.onChange(this);\r\n  };\r\n\r\n  clear = () => {\r\n    this.lines = [];\r\n    this.valuesChanged = true;\r\n    this.ctx.drawing.clearRect(\r\n      0,\r\n      0,\r\n      this.canvas.drawing.width,\r\n      this.canvas.drawing.height\r\n    );\r\n    this.ctx.temp.clearRect(\r\n      0,\r\n      0,\r\n      this.canvas.temp.width,\r\n      this.canvas.temp.height\r\n    );\r\n  };\r\n\r\n  loop = ({ once = false } = {}) => {\r\n    if (this.mouseHasMoved || this.valuesChanged) {\r\n      const pointer = this.lazy.getPointerCoordinates();\r\n      const brush = this.lazy.getBrushCoordinates();\r\n\r\n      this.drawInterface(this.ctx.interface, pointer, brush);\r\n      this.mouseHasMoved = false;\r\n      this.valuesChanged = false;\r\n    }\r\n\r\n    if (!once) {\r\n      window.requestAnimationFrame(() => {\r\n        this.loop();\r\n      });\r\n    }\r\n  };\r\n\r\n  drawGrid = ctx => {\r\n    if (this.props.hideGrid) return;\r\n\r\n    console.log('drawGrid!');\r\n\r\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\r\n\r\n    ctx.beginPath();\r\n    ctx.setLineDash([5, 1]);\r\n    ctx.setLineDash([]);\r\n    ctx.strokeStyle = this.props.gridColor;\r\n    ctx.lineWidth = 0.5;\r\n\r\n    const gridSize = 25;\r\n\r\n    // let countX = 0;\r\n    // while (countX < ctx.canvas.width) {\r\n    //   countX += gridSize;\r\n    //   ctx.moveTo(countX, 0);\r\n    //   ctx.lineTo(countX, ctx.canvas.height);\r\n    // }\r\n    // ctx.stroke();\r\n\r\n    // let countY = 0;\r\n    // while (countY < ctx.canvas.height) {\r\n    //   countY += gridSize;\r\n    //   ctx.moveTo(0, countY);\r\n    //   ctx.lineTo(ctx.canvas.width, countY);\r\n    // }\r\n    // ctx.stroke();\r\n\r\n    let countX = 25;\r\n    let countY = 25;\r\n\r\n    while (countX < ctx.canvas.width) {\r\n      countY = 25;\r\n      while (countY < ctx.canvas.height) {\r\n        ctx.moveTo(countX, countY);\r\n        ctx.arc(countX, countY, 1, 0, 2*Math.PI);\r\n        countY += gridSize;\r\n      }\r\n\r\n      countX += gridSize;\r\n    }\r\n\r\n    ctx.stroke();\r\n  };\r\n\r\n  drawInterface = (ctx, pointer, brush) => {\r\n    if (this.props.hideInterface) return;\r\n\r\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\r\n\r\n    // Draw brush preview\r\n    ctx.beginPath();\r\n    ctx.fillStyle = this.props.brushColor;\r\n    ctx.arc(brush.x, brush.y, this.props.brushRadius, 0, Math.PI * 2, true);\r\n    ctx.fill();\r\n\r\n    // Draw mouse point (the one directly at the cursor)\r\n    ctx.beginPath();\r\n    ctx.fillStyle = this.props.catenaryColor;\r\n    ctx.arc(pointer.x, pointer.y, 4, 0, Math.PI * 2, true);\r\n    ctx.fill();\r\n\r\n    // Draw catenary\r\n    if (this.lazy.isEnabled()) {\r\n      ctx.beginPath();\r\n      ctx.lineWidth = 2;\r\n      ctx.lineCap = \"round\";\r\n      ctx.setLineDash([2, 4]);\r\n      ctx.strokeStyle = this.props.catenaryColor;\r\n      this.catenary.drawToCanvas(\r\n        this.ctx.interface,\r\n        brush,\r\n        pointer,\r\n        this.chainLength\r\n      );\r\n      ctx.stroke();\r\n    }\r\n\r\n    // Draw brush point (the one in the middle of the brush preview)\r\n    ctx.beginPath();\r\n    ctx.fillStyle = this.props.catenaryColor;\r\n    ctx.arc(brush.x, brush.y, 2, 0, Math.PI * 2, true);\r\n    ctx.fill();\r\n  };\r\n\r\n  render() {\r\n    return (\r\n      <div\r\n        className={this.props.className}\r\n        style={{\r\n          display: \"block\",\r\n          background: this.props.backgroundColor,\r\n          touchAction: \"none\",\r\n          width: this.props.canvasWidth,\r\n          height: this.props.canvasHeight,\r\n          ...this.props.style\r\n        }}\r\n        ref={container => {\r\n          if (container) {\r\n            this.canvasContainer = container;\r\n          }\r\n        }}\r\n      >\r\n        {canvasTypes.map(({ name, zIndex }) => {\r\n          const isInterface = name === \"interface\";\r\n          return (\r\n            <canvas\r\n              key={name}\r\n              ref={canvas => {\r\n                if (canvas) {\r\n                  this.canvas[name] = canvas;\r\n                  this.ctx[name] = canvas.getContext(\"2d\");\r\n                }\r\n              }}\r\n              style={{ ...canvasStyle, zIndex }}\r\n              onMouseDown={isInterface ? this.handleDrawStart : undefined}\r\n              onMouseMove={isInterface ? this.handleDrawMove : undefined}\r\n              onMouseUp={isInterface ? this.handleDrawEnd : undefined}\r\n              onMouseOut={isInterface ? this.handleDrawEnd : undefined}\r\n              onTouchStart={isInterface ? this.handleDrawStart : undefined}\r\n              onTouchMove={isInterface ? this.handleDrawMove : undefined}\r\n              onTouchEnd={isInterface ? this.handleDrawEnd : undefined}\r\n              onTouchCancel={isInterface ? this.handleDrawEnd : undefined}\r\n            />\r\n          );\r\n        })}\r\n      </div>\r\n    );\r\n  }\r\n}","C:\\Users\\Youn\\draft-app\\src\\my-canvas\\drawImage.js",[],{"ruleId":"47","replacedBy":"48"},{"ruleId":"49","replacedBy":"50"},{"ruleId":"51","severity":1,"message":"52","line":3,"column":43,"nodeType":"53","messageId":"54","endLine":3,"endColumn":55},{"ruleId":"51","severity":1,"message":"55","line":9,"column":8,"nodeType":"53","messageId":"54","endLine":9,"endColumn":19},{"ruleId":"51","severity":1,"message":"56","line":17,"column":7,"nodeType":"53","messageId":"54","endLine":17,"endColumn":25},{"ruleId":"57","severity":1,"message":"58","line":35,"column":13,"nodeType":"59","messageId":"60","endLine":35,"endColumn":15},{"ruleId":"57","severity":1,"message":"58","line":36,"column":29,"nodeType":"59","messageId":"60","endLine":36,"endColumn":31},{"ruleId":"57","severity":1,"message":"58","line":38,"column":29,"nodeType":"59","messageId":"60","endLine":38,"endColumn":31},{"ruleId":"57","severity":1,"message":"58","line":57,"column":41,"nodeType":"59","messageId":"60","endLine":57,"endColumn":43},{"ruleId":"57","severity":1,"message":"58","line":68,"column":67,"nodeType":"59","messageId":"60","endLine":68,"endColumn":69},{"ruleId":"57","severity":1,"message":"58","line":83,"column":14,"nodeType":"59","messageId":"60","endLine":83,"endColumn":16},{"ruleId":"57","severity":1,"message":"58","line":114,"column":31,"nodeType":"59","messageId":"60","endLine":114,"endColumn":33},{"ruleId":"57","severity":1,"message":"58","line":131,"column":19,"nodeType":"59","messageId":"60","endLine":131,"endColumn":21},{"ruleId":"61","severity":1,"message":"62","line":46,"column":1,"nodeType":"63","endLine":619,"endColumn":2},"no-native-reassign",["64"],"no-negated-in-lhs",["65"],"no-unused-vars","'convertToRaw' is defined but never used.","Identifier","unusedVar","'appInsights' is defined but never used.","'compositeDecorator' is assigned a value but never used.","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","import/no-anonymous-default-export","Unexpected default export of anonymous class","ExportDefaultDeclaration","no-global-assign","no-unsafe-negation"]